#include <iostream>
#include"tree.h"
#include<map>


int main()
{
    setlocale(LC_ALL, "RU");
    BST<int> t;
    t.add(14);
    t.add(8);
    t.add(10);
    t.add(3);
    t.add(1);
    t.add(4);
    t.add(9);
    t.add(11);
    t.add(19);
    t.add(17);
    t.add(25);
    t.add(16);
    t.add(18);
    t.add(23);
    t.add(27);
    t.infix();

    std::cout << "первый элемент большe либо равный 18= " << t.greaterorequal(18)->data << " первый элемент меньше либо равный 18= " << t.lessorequal(18)->data << std::endl;
    std::cout << "первый элемент большe либо равный 27= " << t.greaterorequal(27)->data << " первый элемент меньше либо равный 1= " << t.lessorequal(1)->data << std::endl;

    t.printwithqueue();
    t.printwithstack();
    std::cout << "следующий элемент после 11= " << t.next(t.find(11))->data << " предыдущий элемент перед 11= " << t.prev(t.find(11))->data << std::endl;
    std::cout << "следующий элемент после 14= " << t.next(t.find(14))->data << " предыдущий элемент перед 27= " << t.prev(t.find(27))->data << std::endl;

    BST<int> t1;
    t1.add(14);
    t1.add(8);
    t1.add(10);
    t1.add(3);
    t1.add(1);
    t1.add(4);
    t1.add(9);
    t1.add(11);
    t1.add(19);
    t1.add(17);
    t1.add(25);
    t1.add(16);
    t1.add(18);
    t1.add(23);
    t1.add(27);
    
    std::cout << "проверка одинаковых деревьев на равенство: " << isequal(t, t1) << std::endl;
    std::cout << "при удалии из дерева t1 корень получим:";
    t1.delinbst(14);
    t1.infix();

    std::cout << "проверка не одинаковых деревьев на равенство: " << isequal(t, t1) << std::endl;

    Eratosthene(3000);
    Eratosthene1(3000);
}

/*
инфиксный вывод дерева:1 3 4 8 9 10 11 14 16 17 18 19 23 25 27
первый элемент большe либо равный 18= 19 первый элемент меньше либо равный 18= 14
первый элемент большe либо равный 27= 27 первый элемент меньше либо равный 1= 1
вывод дерева по слоям:14 8 19 3 10 17 25 1 4 9 11 16 18 23 27
вывод дерева в форме пкл:27 25 23 19 18 17 16 14 11 10 9 8 4 3 1
следующий элемент после 11= 14 предыдущий элемент перед 11= 10
следующий элемент после 14= 16 предыдущий элемент перед 27= 25
проверка одинаковых деревьев на равенство: 1
при удалии из дерева t1 корень получим:инфиксный вывод дерева:1 3 4 8 9 10 11 16 17 18 19 23 25 27
проверка не одинаковых деревьев на равенство: 0
время работы алгоритма с использованием дерева при n= 3000 составляет:67мс
время работы алгоритма с использованием std::vector при n= 3000 составляет:9мс
*/